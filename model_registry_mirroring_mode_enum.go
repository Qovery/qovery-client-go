/*
Qovery API

- Qovery is the fastest way to deploy your full-stack apps on any Cloud provider. - ℹ️ The API is stable and still in development.

API version: 1.0.3
Contact: support+api+documentation@qovery.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package qovery

import (
	"encoding/json"
	"fmt"
)

// RegistryMirroringModeEnum Mirroring mode when deploying a service from a container registry - CLUSTER: This is not available on Scaleway. Images within the mirroring registry are organized by \"Qovery cluster\", meaning that the application deployed on the same cluster are all mirrored on the same repository. - SERVICE: Images within the mirroring registry are organized by \"Qovery service\", each service has its own repository
type RegistryMirroringModeEnum string

// List of RegistryMirroringModeEnum
const (
	REGISTRYMIRRORINGMODEENUM_CLUSTER RegistryMirroringModeEnum = "CLUSTER"
	REGISTRYMIRRORINGMODEENUM_SERVICE RegistryMirroringModeEnum = "SERVICE"
)

// All allowed values of RegistryMirroringModeEnum enum
var AllowedRegistryMirroringModeEnumEnumValues = []RegistryMirroringModeEnum{
	"CLUSTER",
	"SERVICE",
}

func (v *RegistryMirroringModeEnum) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := RegistryMirroringModeEnum(value)
	for _, existing := range AllowedRegistryMirroringModeEnumEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid RegistryMirroringModeEnum", value)
}

// NewRegistryMirroringModeEnumFromValue returns a pointer to a valid RegistryMirroringModeEnum
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewRegistryMirroringModeEnumFromValue(v string) (*RegistryMirroringModeEnum, error) {
	ev := RegistryMirroringModeEnum(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for RegistryMirroringModeEnum: valid values are %v", v, AllowedRegistryMirroringModeEnumEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v RegistryMirroringModeEnum) IsValid() bool {
	for _, existing := range AllowedRegistryMirroringModeEnumEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to RegistryMirroringModeEnum value
func (v RegistryMirroringModeEnum) Ptr() *RegistryMirroringModeEnum {
	return &v
}

type NullableRegistryMirroringModeEnum struct {
	value *RegistryMirroringModeEnum
	isSet bool
}

func (v NullableRegistryMirroringModeEnum) Get() *RegistryMirroringModeEnum {
	return v.value
}

func (v *NullableRegistryMirroringModeEnum) Set(val *RegistryMirroringModeEnum) {
	v.value = val
	v.isSet = true
}

func (v NullableRegistryMirroringModeEnum) IsSet() bool {
	return v.isSet
}

func (v *NullableRegistryMirroringModeEnum) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRegistryMirroringModeEnum(val *RegistryMirroringModeEnum) *NullableRegistryMirroringModeEnum {
	return &NullableRegistryMirroringModeEnum{value: val, isSet: true}
}

func (v NullableRegistryMirroringModeEnum) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRegistryMirroringModeEnum) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
